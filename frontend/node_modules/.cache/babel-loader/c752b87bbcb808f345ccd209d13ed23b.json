{"ast":null,"code":"import _slicedToArray from \"C:/JZ/code/Hack-the-North/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { isFunction, defaults, isCubicBezier, progress } from '@motionone/utils';\nimport { supports } from './feature-detection.es.js'; // Create a linear easing point for every x second\n\nvar resolution = 0.015;\n\nvar generateLinearEasingPoints = function generateLinearEasingPoints(easing, duration) {\n  var points = \"\";\n  var numPoints = Math.round(duration / resolution);\n\n  for (var i = 0; i < numPoints; i++) {\n    points += easing(progress(0, numPoints - 1, i)) + \", \";\n  }\n\n  return points.substring(0, points.length - 2);\n};\n\nvar convertEasing = function convertEasing(easing, duration) {\n  if (isFunction(easing)) {\n    return supports.linearEasing() ? \"linear(\".concat(generateLinearEasingPoints(easing, duration), \")\") : defaults.easing;\n  } else {\n    return isCubicBezier(easing) ? cubicBezierAsString(easing) : easing;\n  }\n};\n\nvar cubicBezierAsString = function cubicBezierAsString(_ref) {\n  var _ref2 = _slicedToArray(_ref, 4),\n      a = _ref2[0],\n      b = _ref2[1],\n      c = _ref2[2],\n      d = _ref2[3];\n\n  return \"cubic-bezier(\".concat(a, \", \").concat(b, \", \").concat(c, \", \").concat(d, \")\");\n};\n\nexport { convertEasing, cubicBezierAsString, generateLinearEasingPoints };","map":{"version":3,"names":["isFunction","defaults","isCubicBezier","progress","supports","resolution","generateLinearEasingPoints","easing","duration","points","numPoints","Math","round","i","substring","length","convertEasing","linearEasing","cubicBezierAsString","a","b","c","d"],"sources":["C:/JZ/code/Hack-the-North/frontend/node_modules/@motionone/dom/dist/animate/utils/easing.es.js"],"sourcesContent":["import { isFunction, defaults, isCubicBezier, progress } from '@motionone/utils';\r\nimport { supports } from './feature-detection.es.js';\r\n\r\n// Create a linear easing point for every x second\r\nconst resolution = 0.015;\r\nconst generateLinearEasingPoints = (easing, duration) => {\r\n    let points = \"\";\r\n    const numPoints = Math.round(duration / resolution);\r\n    for (let i = 0; i < numPoints; i++) {\r\n        points += easing(progress(0, numPoints - 1, i)) + \", \";\r\n    }\r\n    return points.substring(0, points.length - 2);\r\n};\r\nconst convertEasing = (easing, duration) => {\r\n    if (isFunction(easing)) {\r\n        return supports.linearEasing()\r\n            ? `linear(${generateLinearEasingPoints(easing, duration)})`\r\n            : defaults.easing;\r\n    }\r\n    else {\r\n        return isCubicBezier(easing) ? cubicBezierAsString(easing) : easing;\r\n    }\r\n};\r\nconst cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;\r\n\r\nexport { convertEasing, cubicBezierAsString, generateLinearEasingPoints };\r\n"],"mappings":";AAAA,SAASA,UAAT,EAAqBC,QAArB,EAA+BC,aAA/B,EAA8CC,QAA9C,QAA8D,kBAA9D;AACA,SAASC,QAAT,QAAyB,2BAAzB,C,CAEA;;AACA,IAAMC,UAAU,GAAG,KAAnB;;AACA,IAAMC,0BAA0B,GAAG,SAA7BA,0BAA6B,CAACC,MAAD,EAASC,QAAT,EAAsB;EACrD,IAAIC,MAAM,GAAG,EAAb;EACA,IAAMC,SAAS,GAAGC,IAAI,CAACC,KAAL,CAAWJ,QAAQ,GAAGH,UAAtB,CAAlB;;EACA,KAAK,IAAIQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,SAApB,EAA+BG,CAAC,EAAhC,EAAoC;IAChCJ,MAAM,IAAIF,MAAM,CAACJ,QAAQ,CAAC,CAAD,EAAIO,SAAS,GAAG,CAAhB,EAAmBG,CAAnB,CAAT,CAAN,GAAwC,IAAlD;EACH;;EACD,OAAOJ,MAAM,CAACK,SAAP,CAAiB,CAAjB,EAAoBL,MAAM,CAACM,MAAP,GAAgB,CAApC,CAAP;AACH,CAPD;;AAQA,IAAMC,aAAa,GAAG,SAAhBA,aAAgB,CAACT,MAAD,EAASC,QAAT,EAAsB;EACxC,IAAIR,UAAU,CAACO,MAAD,CAAd,EAAwB;IACpB,OAAOH,QAAQ,CAACa,YAAT,sBACSX,0BAA0B,CAACC,MAAD,EAASC,QAAT,CADnC,SAEDP,QAAQ,CAACM,MAFf;EAGH,CAJD,MAKK;IACD,OAAOL,aAAa,CAACK,MAAD,CAAb,GAAwBW,mBAAmB,CAACX,MAAD,CAA3C,GAAsDA,MAA7D;EACH;AACJ,CATD;;AAUA,IAAMW,mBAAmB,GAAG,SAAtBA,mBAAsB;EAAA;EAAA,IAAEC,CAAF;EAAA,IAAKC,CAAL;EAAA,IAAQC,CAAR;EAAA,IAAWC,CAAX;;EAAA,8BAAkCH,CAAlC,eAAwCC,CAAxC,eAA8CC,CAA9C,eAAoDC,CAApD;AAAA,CAA5B;;AAEA,SAASN,aAAT,EAAwBE,mBAAxB,EAA6CZ,0BAA7C"},"metadata":{},"sourceType":"module"}