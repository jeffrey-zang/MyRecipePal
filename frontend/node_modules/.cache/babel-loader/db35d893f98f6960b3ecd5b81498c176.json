{"ast":null,"code":"import _objectSpread from \"C:/JZ/code/Hack-the-North/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"C:/JZ/code/Hack-the-North/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"transition\", \"transitionEnd\"];\nimport { visualElement } from '../index.mjs';\nimport { getOrigin, checkTargetForNewValues } from '../utils/setters.mjs';\nimport { buildHTMLStyles } from './utils/build-styles.mjs';\nimport { isCSSVariable } from '../dom/utils/is-css-variable.mjs';\nimport { parseDomVariant } from '../dom/utils/parse-dom-variant.mjs';\nimport { transformProps } from './utils/transform.mjs';\nimport { scrapeMotionValuesFromProps } from './utils/scrape-motion-values.mjs';\nimport { renderHTML } from './utils/render.mjs';\nimport { getDefaultValueType } from '../dom/value-types/defaults.mjs';\nimport { measureViewportBox as _measureViewportBox } from '../../projection/utils/measure.mjs';\n\nfunction getComputedStyle(element) {\n  return window.getComputedStyle(element);\n}\n\nvar htmlConfig = {\n  treeType: \"dom\",\n  readValueFromInstance: function readValueFromInstance(domElement, key) {\n    if (transformProps.has(key)) {\n      var defaultType = getDefaultValueType(key);\n      return defaultType ? defaultType.default || 0 : 0;\n    } else {\n      var computedStyle = getComputedStyle(domElement);\n      var value = (isCSSVariable(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;\n      return typeof value === \"string\" ? value.trim() : value;\n    }\n  },\n  sortNodePosition: function sortNodePosition(a, b) {\n    /**\r\n     * compareDocumentPosition returns a bitmask, by using the bitwise &\r\n     * we're returning true if 2 in that bitmask is set to true. 2 is set\r\n     * to true if b preceeds a.\r\n     */\n    return a.compareDocumentPosition(b) & 2 ? 1 : -1;\n  },\n  getBaseTarget: function getBaseTarget(props, key) {\n    var _a;\n\n    return (_a = props.style) === null || _a === void 0 ? void 0 : _a[key];\n  },\n  measureViewportBox: function measureViewportBox(element, _ref) {\n    var transformPagePoint = _ref.transformPagePoint;\n    return _measureViewportBox(element, transformPagePoint);\n  },\n\n  /**\r\n   * Reset the transform on the current Element. This is called as part\r\n   * of a batched process across the entire layout tree. To remove this write\r\n   * cycle it'd be interesting to see if it's possible to \"undo\" all the current\r\n   * layout transforms up the tree in the same way this.getBoundingBoxWithoutTransforms\r\n   * works\r\n   */\n  resetTransform: function resetTransform(element, domElement, props) {\n    var transformTemplate = props.transformTemplate;\n    domElement.style.transform = transformTemplate ? transformTemplate({}, \"\") : \"none\"; // Ensure that whatever happens next, we restore our transform on the next frame\n\n    element.scheduleRender();\n  },\n  restoreTransform: function restoreTransform(instance, mutableState) {\n    instance.style.transform = mutableState.style.transform;\n  },\n  removeValueFromRenderState: function removeValueFromRenderState(key, _ref2) {\n    var vars = _ref2.vars,\n        style = _ref2.style;\n    delete vars[key];\n    delete style[key];\n  },\n\n  /**\r\n   * Ensure that HTML and Framer-specific value types like `px`->`%` and `Color`\r\n   * can be animated by Motion.\r\n   */\n  makeTargetAnimatable: function makeTargetAnimatable(element, _ref3, _ref4) {\n    var transition = _ref3.transition,\n        transitionEnd = _ref3.transitionEnd,\n        target = _objectWithoutProperties(_ref3, _excluded);\n\n    var transformValues = _ref4.transformValues;\n    var isMounted = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    var origin = getOrigin(target, transition || {}, element);\n    /**\r\n     * If Framer has provided a function to convert `Color` etc value types, convert them\r\n     */\n\n    if (transformValues) {\n      if (transitionEnd) transitionEnd = transformValues(transitionEnd);\n      if (target) target = transformValues(target);\n      if (origin) origin = transformValues(origin);\n    }\n\n    if (isMounted) {\n      checkTargetForNewValues(element, target, origin);\n      var parsed = parseDomVariant(element, target, origin, transitionEnd);\n      transitionEnd = parsed.transitionEnd;\n      target = parsed.target;\n    }\n\n    return _objectSpread({\n      transition: transition,\n      transitionEnd: transitionEnd\n    }, target);\n  },\n  scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,\n  build: function build(element, renderState, latestValues, options, props) {\n    if (element.isVisible !== undefined) {\n      renderState.style.visibility = element.isVisible ? \"visible\" : \"hidden\";\n    }\n\n    buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);\n  },\n  render: renderHTML\n};\nvar htmlVisualElement = visualElement(htmlConfig);\nexport { getComputedStyle, htmlConfig, htmlVisualElement };","map":{"version":3,"names":["visualElement","getOrigin","checkTargetForNewValues","buildHTMLStyles","isCSSVariable","parseDomVariant","transformProps","scrapeMotionValuesFromProps","renderHTML","getDefaultValueType","measureViewportBox","getComputedStyle","element","window","htmlConfig","treeType","readValueFromInstance","domElement","key","has","defaultType","default","computedStyle","value","getPropertyValue","trim","sortNodePosition","a","b","compareDocumentPosition","getBaseTarget","props","_a","style","transformPagePoint","resetTransform","transformTemplate","transform","scheduleRender","restoreTransform","instance","mutableState","removeValueFromRenderState","vars","makeTargetAnimatable","transition","transitionEnd","target","transformValues","isMounted","origin","parsed","build","renderState","latestValues","options","isVisible","undefined","visibility","render","htmlVisualElement"],"sources":["C:/JZ/code/Hack-the-North/frontend/node_modules/framer-motion/dist/es/render/html/visual-element.mjs"],"sourcesContent":["import { visualElement } from '../index.mjs';\r\nimport { getOrigin, checkTargetForNewValues } from '../utils/setters.mjs';\r\nimport { buildHTMLStyles } from './utils/build-styles.mjs';\r\nimport { isCSSVariable } from '../dom/utils/is-css-variable.mjs';\r\nimport { parseDomVariant } from '../dom/utils/parse-dom-variant.mjs';\r\nimport { transformProps } from './utils/transform.mjs';\r\nimport { scrapeMotionValuesFromProps } from './utils/scrape-motion-values.mjs';\r\nimport { renderHTML } from './utils/render.mjs';\r\nimport { getDefaultValueType } from '../dom/value-types/defaults.mjs';\r\nimport { measureViewportBox } from '../../projection/utils/measure.mjs';\r\n\r\nfunction getComputedStyle(element) {\r\n    return window.getComputedStyle(element);\r\n}\r\nconst htmlConfig = {\r\n    treeType: \"dom\",\r\n    readValueFromInstance(domElement, key) {\r\n        if (transformProps.has(key)) {\r\n            const defaultType = getDefaultValueType(key);\r\n            return defaultType ? defaultType.default || 0 : 0;\r\n        }\r\n        else {\r\n            const computedStyle = getComputedStyle(domElement);\r\n            const value = (isCSSVariable(key)\r\n                ? computedStyle.getPropertyValue(key)\r\n                : computedStyle[key]) || 0;\r\n            return typeof value === \"string\" ? value.trim() : value;\r\n        }\r\n    },\r\n    sortNodePosition(a, b) {\r\n        /**\r\n         * compareDocumentPosition returns a bitmask, by using the bitwise &\r\n         * we're returning true if 2 in that bitmask is set to true. 2 is set\r\n         * to true if b preceeds a.\r\n         */\r\n        return a.compareDocumentPosition(b) & 2 ? 1 : -1;\r\n    },\r\n    getBaseTarget(props, key) {\r\n        var _a;\r\n        return (_a = props.style) === null || _a === void 0 ? void 0 : _a[key];\r\n    },\r\n    measureViewportBox(element, { transformPagePoint }) {\r\n        return measureViewportBox(element, transformPagePoint);\r\n    },\r\n    /**\r\n     * Reset the transform on the current Element. This is called as part\r\n     * of a batched process across the entire layout tree. To remove this write\r\n     * cycle it'd be interesting to see if it's possible to \"undo\" all the current\r\n     * layout transforms up the tree in the same way this.getBoundingBoxWithoutTransforms\r\n     * works\r\n     */\r\n    resetTransform(element, domElement, props) {\r\n        const { transformTemplate } = props;\r\n        domElement.style.transform = transformTemplate\r\n            ? transformTemplate({}, \"\")\r\n            : \"none\";\r\n        // Ensure that whatever happens next, we restore our transform on the next frame\r\n        element.scheduleRender();\r\n    },\r\n    restoreTransform(instance, mutableState) {\r\n        instance.style.transform = mutableState.style.transform;\r\n    },\r\n    removeValueFromRenderState(key, { vars, style }) {\r\n        delete vars[key];\r\n        delete style[key];\r\n    },\r\n    /**\r\n     * Ensure that HTML and Framer-specific value types like `px`->`%` and `Color`\r\n     * can be animated by Motion.\r\n     */\r\n    makeTargetAnimatable(element, { transition, transitionEnd, ...target }, { transformValues }, isMounted = true) {\r\n        let origin = getOrigin(target, transition || {}, element);\r\n        /**\r\n         * If Framer has provided a function to convert `Color` etc value types, convert them\r\n         */\r\n        if (transformValues) {\r\n            if (transitionEnd)\r\n                transitionEnd = transformValues(transitionEnd);\r\n            if (target)\r\n                target = transformValues(target);\r\n            if (origin)\r\n                origin = transformValues(origin);\r\n        }\r\n        if (isMounted) {\r\n            checkTargetForNewValues(element, target, origin);\r\n            const parsed = parseDomVariant(element, target, origin, transitionEnd);\r\n            transitionEnd = parsed.transitionEnd;\r\n            target = parsed.target;\r\n        }\r\n        return {\r\n            transition,\r\n            transitionEnd,\r\n            ...target,\r\n        };\r\n    },\r\n    scrapeMotionValuesFromProps,\r\n    build(element, renderState, latestValues, options, props) {\r\n        if (element.isVisible !== undefined) {\r\n            renderState.style.visibility = element.isVisible\r\n                ? \"visible\"\r\n                : \"hidden\";\r\n        }\r\n        buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);\r\n    },\r\n    render: renderHTML,\r\n};\r\nconst htmlVisualElement = visualElement(htmlConfig);\r\n\r\nexport { getComputedStyle, htmlConfig, htmlVisualElement };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}