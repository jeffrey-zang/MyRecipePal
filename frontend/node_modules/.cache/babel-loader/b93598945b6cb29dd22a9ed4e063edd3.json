{"ast":null,"code":"import _slicedToArray from \"C:/JZ/code/Hack-the-North/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectSpread from \"C:/JZ/code/Hack-the-North/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { px, number } from 'style-value-types';\nimport { isKeyframesTarget } from '../../../animation/utils/is-keyframes-target.mjs';\nimport { invariant } from 'hey-listen';\nimport { transformPropOrder } from '../../html/utils/transform.mjs';\nimport { findDimensionValueType } from '../value-types/dimensions.mjs';\nimport { isBrowser } from '../../../utils/is-browser.mjs';\nvar positionalKeys = new Set([\"width\", \"height\", \"top\", \"left\", \"right\", \"bottom\", \"x\", \"y\"]);\n\nvar isPositionalKey = function isPositionalKey(key) {\n  return positionalKeys.has(key);\n};\n\nvar hasPositionalKey = function hasPositionalKey(target) {\n  return Object.keys(target).some(isPositionalKey);\n};\n\nvar setAndResetVelocity = function setAndResetVelocity(value, to) {\n  // Looks odd but setting it twice doesn't render, it'll just\n  // set both prev and current to the latest value\n  value.set(to, false);\n  value.set(to);\n};\n\nvar isNumOrPxType = function isNumOrPxType(v) {\n  return v === number || v === px;\n};\n\nvar BoundingBoxDimension;\n\n(function (BoundingBoxDimension) {\n  BoundingBoxDimension[\"width\"] = \"width\";\n  BoundingBoxDimension[\"height\"] = \"height\";\n  BoundingBoxDimension[\"left\"] = \"left\";\n  BoundingBoxDimension[\"right\"] = \"right\";\n  BoundingBoxDimension[\"top\"] = \"top\";\n  BoundingBoxDimension[\"bottom\"] = \"bottom\";\n})(BoundingBoxDimension || (BoundingBoxDimension = {}));\n\nvar getPosFromMatrix = function getPosFromMatrix(matrix, pos) {\n  return parseFloat(matrix.split(\", \")[pos]);\n};\n\nvar getTranslateFromMatrix = function getTranslateFromMatrix(pos2, pos3) {\n  return function (_bbox, _ref) {\n    var transform = _ref.transform;\n    if (transform === \"none\" || !transform) return 0;\n    var matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\n\n    if (matrix3d) {\n      return getPosFromMatrix(matrix3d[1], pos3);\n    } else {\n      var matrix = transform.match(/^matrix\\((.+)\\)$/);\n\n      if (matrix) {\n        return getPosFromMatrix(matrix[1], pos2);\n      } else {\n        return 0;\n      }\n    }\n  };\n};\n\nvar transformKeys = new Set([\"x\", \"y\", \"z\"]);\nvar nonTranslationalTransformKeys = transformPropOrder.filter(function (key) {\n  return !transformKeys.has(key);\n});\n\nfunction removeNonTranslationalTransform(visualElement) {\n  var removedTransforms = [];\n  nonTranslationalTransformKeys.forEach(function (key) {\n    var value = visualElement.getValue(key);\n\n    if (value !== undefined) {\n      removedTransforms.push([key, value.get()]);\n      value.set(key.startsWith(\"scale\") ? 1 : 0);\n    }\n  }); // Apply changes to element before measurement\n\n  if (removedTransforms.length) visualElement.syncRender();\n  return removedTransforms;\n}\n\nvar positionalValues = {\n  // Dimensions\n  width: function width(_ref2, _ref3) {\n    var x = _ref2.x;\n    var _ref3$paddingLeft = _ref3.paddingLeft,\n        paddingLeft = _ref3$paddingLeft === void 0 ? \"0\" : _ref3$paddingLeft,\n        _ref3$paddingRight = _ref3.paddingRight,\n        paddingRight = _ref3$paddingRight === void 0 ? \"0\" : _ref3$paddingRight;\n    return x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight);\n  },\n  height: function height(_ref4, _ref5) {\n    var y = _ref4.y;\n    var _ref5$paddingTop = _ref5.paddingTop,\n        paddingTop = _ref5$paddingTop === void 0 ? \"0\" : _ref5$paddingTop,\n        _ref5$paddingBottom = _ref5.paddingBottom,\n        paddingBottom = _ref5$paddingBottom === void 0 ? \"0\" : _ref5$paddingBottom;\n    return y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom);\n  },\n  top: function top(_bbox, _ref6) {\n    var _top = _ref6.top;\n    return parseFloat(_top);\n  },\n  left: function left(_bbox, _ref7) {\n    var _left = _ref7.left;\n    return parseFloat(_left);\n  },\n  bottom: function bottom(_ref8, _ref9) {\n    var y = _ref8.y;\n    var top = _ref9.top;\n    return parseFloat(top) + (y.max - y.min);\n  },\n  right: function right(_ref10, _ref11) {\n    var x = _ref10.x;\n    var left = _ref11.left;\n    return parseFloat(left) + (x.max - x.min);\n  },\n  // Transform\n  x: getTranslateFromMatrix(4, 13),\n  y: getTranslateFromMatrix(5, 14)\n};\n\nvar convertChangedValueTypes = function convertChangedValueTypes(target, visualElement, changedKeys) {\n  var originBbox = visualElement.measureViewportBox();\n  var element = visualElement.getInstance();\n  var elementComputedStyle = getComputedStyle(element);\n  var display = elementComputedStyle.display;\n  var origin = {}; // If the element is currently set to display: \"none\", make it visible before\n  // measuring the target bounding box\n\n  if (display === \"none\") {\n    visualElement.setStaticValue(\"display\", target.display || \"block\");\n  }\n  /**\r\n   * Record origins before we render and update styles\r\n   */\n\n\n  changedKeys.forEach(function (key) {\n    origin[key] = positionalValues[key](originBbox, elementComputedStyle);\n  }); // Apply the latest values (as set in checkAndConvertChangedValueTypes)\n\n  visualElement.syncRender();\n  var targetBbox = visualElement.measureViewportBox();\n  changedKeys.forEach(function (key) {\n    // Restore styles to their **calculated computed style**, not their actual\n    // originally set style. This allows us to animate between equivalent pixel units.\n    var value = visualElement.getValue(key);\n    setAndResetVelocity(value, origin[key]);\n    target[key] = positionalValues[key](targetBbox, elementComputedStyle);\n  });\n  return target;\n};\n\nvar checkAndConvertChangedValueTypes = function checkAndConvertChangedValueTypes(visualElement, target) {\n  var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var transitionEnd = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  target = _objectSpread({}, target);\n  transitionEnd = _objectSpread({}, transitionEnd);\n  var targetPositionalKeys = Object.keys(target).filter(isPositionalKey); // We want to remove any transform values that could affect the element's bounding box before\n  // it's measured. We'll reapply these later.\n\n  var removedTransformValues = [];\n  var hasAttemptedToRemoveTransformValues = false;\n  var changedValueTypeKeys = [];\n  targetPositionalKeys.forEach(function (key) {\n    var value = visualElement.getValue(key);\n    if (!visualElement.hasValue(key)) return;\n    var from = origin[key];\n    var fromType = findDimensionValueType(from);\n    var to = target[key];\n    var toType; // TODO: The current implementation of this basically throws an error\n    // if you try and do value conversion via keyframes. There's probably\n    // a way of doing this but the performance implications would need greater scrutiny,\n    // as it'd be doing multiple resize-remeasure operations.\n\n    if (isKeyframesTarget(to)) {\n      var numKeyframes = to.length;\n      var fromIndex = to[0] === null ? 1 : 0;\n      from = to[fromIndex];\n      fromType = findDimensionValueType(from);\n\n      for (var i = fromIndex; i < numKeyframes; i++) {\n        if (!toType) {\n          toType = findDimensionValueType(to[i]);\n          invariant(toType === fromType || isNumOrPxType(fromType) && isNumOrPxType(toType), \"Keyframes must be of the same dimension as the current value\");\n        } else {\n          invariant(findDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\n        }\n      }\n    } else {\n      toType = findDimensionValueType(to);\n    }\n\n    if (fromType !== toType) {\n      // If they're both just number or px, convert them both to numbers rather than\n      // relying on resize/remeasure to convert (which is wasteful in this situation)\n      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\n        var current = value.get();\n\n        if (typeof current === \"string\") {\n          value.set(parseFloat(current));\n        }\n\n        if (typeof to === \"string\") {\n          target[key] = parseFloat(to);\n        } else if (Array.isArray(to) && toType === px) {\n          target[key] = to.map(parseFloat);\n        }\n      } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from === 0 || to === 0)) {\n        // If one or the other value is 0, it's safe to coerce it to the\n        // type of the other without measurement\n        if (from === 0) {\n          value.set(toType.transform(from));\n        } else {\n          target[key] = fromType.transform(to);\n        }\n      } else {\n        // If we're going to do value conversion via DOM measurements, we first\n        // need to remove non-positional transform values that could affect the bbox measurements.\n        if (!hasAttemptedToRemoveTransformValues) {\n          removedTransformValues = removeNonTranslationalTransform(visualElement);\n          hasAttemptedToRemoveTransformValues = true;\n        }\n\n        changedValueTypeKeys.push(key);\n        transitionEnd[key] = transitionEnd[key] !== undefined ? transitionEnd[key] : target[key];\n        setAndResetVelocity(value, to);\n      }\n    }\n  });\n\n  if (changedValueTypeKeys.length) {\n    var scrollY = changedValueTypeKeys.indexOf(\"height\") >= 0 ? window.pageYOffset : null;\n    var convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys); // If we removed transform values, reapply them before the next render\n\n    if (removedTransformValues.length) {\n      removedTransformValues.forEach(function (_ref12) {\n        var _ref13 = _slicedToArray(_ref12, 2),\n            key = _ref13[0],\n            value = _ref13[1];\n\n        visualElement.getValue(key).set(value);\n      });\n    } // Reapply original values\n\n\n    visualElement.syncRender(); // Restore scroll position\n\n    if (isBrowser && scrollY !== null) {\n      window.scrollTo({\n        top: scrollY\n      });\n    }\n\n    return {\n      target: convertedTarget,\n      transitionEnd: transitionEnd\n    };\n  } else {\n    return {\n      target: target,\n      transitionEnd: transitionEnd\n    };\n  }\n};\n/**\r\n * Convert value types for x/y/width/height/top/left/bottom/right\r\n *\r\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\r\n *\r\n * @internal\r\n */\n\n\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\n  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd) : {\n    target: target,\n    transitionEnd: transitionEnd\n  };\n}\n\nexport { BoundingBoxDimension, positionalValues, unitConversion };","map":{"version":3,"names":["px","number","isKeyframesTarget","invariant","transformPropOrder","findDimensionValueType","isBrowser","positionalKeys","Set","isPositionalKey","key","has","hasPositionalKey","target","Object","keys","some","setAndResetVelocity","value","to","set","isNumOrPxType","v","BoundingBoxDimension","getPosFromMatrix","matrix","pos","parseFloat","split","getTranslateFromMatrix","pos2","pos3","_bbox","transform","matrix3d","match","transformKeys","nonTranslationalTransformKeys","filter","removeNonTranslationalTransform","visualElement","removedTransforms","forEach","getValue","undefined","push","get","startsWith","length","syncRender","positionalValues","width","x","paddingLeft","paddingRight","max","min","height","y","paddingTop","paddingBottom","top","left","bottom","right","convertChangedValueTypes","changedKeys","originBbox","measureViewportBox","element","getInstance","elementComputedStyle","getComputedStyle","display","origin","setStaticValue","targetBbox","checkAndConvertChangedValueTypes","transitionEnd","targetPositionalKeys","removedTransformValues","hasAttemptedToRemoveTransformValues","changedValueTypeKeys","hasValue","from","fromType","toType","numKeyframes","fromIndex","i","current","Array","isArray","map","scrollY","indexOf","window","pageYOffset","convertedTarget","scrollTo","unitConversion"],"sources":["C:/JZ/code/Hack-the-North/frontend/node_modules/framer-motion/dist/es/render/dom/utils/unit-conversion.mjs"],"sourcesContent":["import { px, number } from 'style-value-types';\r\nimport { isKeyframesTarget } from '../../../animation/utils/is-keyframes-target.mjs';\r\nimport { invariant } from 'hey-listen';\r\nimport { transformPropOrder } from '../../html/utils/transform.mjs';\r\nimport { findDimensionValueType } from '../value-types/dimensions.mjs';\r\nimport { isBrowser } from '../../../utils/is-browser.mjs';\r\n\r\nconst positionalKeys = new Set([\r\n    \"width\",\r\n    \"height\",\r\n    \"top\",\r\n    \"left\",\r\n    \"right\",\r\n    \"bottom\",\r\n    \"x\",\r\n    \"y\",\r\n]);\r\nconst isPositionalKey = (key) => positionalKeys.has(key);\r\nconst hasPositionalKey = (target) => {\r\n    return Object.keys(target).some(isPositionalKey);\r\n};\r\nconst setAndResetVelocity = (value, to) => {\r\n    // Looks odd but setting it twice doesn't render, it'll just\r\n    // set both prev and current to the latest value\r\n    value.set(to, false);\r\n    value.set(to);\r\n};\r\nconst isNumOrPxType = (v) => v === number || v === px;\r\nvar BoundingBoxDimension;\r\n(function (BoundingBoxDimension) {\r\n    BoundingBoxDimension[\"width\"] = \"width\";\r\n    BoundingBoxDimension[\"height\"] = \"height\";\r\n    BoundingBoxDimension[\"left\"] = \"left\";\r\n    BoundingBoxDimension[\"right\"] = \"right\";\r\n    BoundingBoxDimension[\"top\"] = \"top\";\r\n    BoundingBoxDimension[\"bottom\"] = \"bottom\";\r\n})(BoundingBoxDimension || (BoundingBoxDimension = {}));\r\nconst getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(\", \")[pos]);\r\nconst getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform }) => {\r\n    if (transform === \"none\" || !transform)\r\n        return 0;\r\n    const matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\r\n    if (matrix3d) {\r\n        return getPosFromMatrix(matrix3d[1], pos3);\r\n    }\r\n    else {\r\n        const matrix = transform.match(/^matrix\\((.+)\\)$/);\r\n        if (matrix) {\r\n            return getPosFromMatrix(matrix[1], pos2);\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n};\r\nconst transformKeys = new Set([\"x\", \"y\", \"z\"]);\r\nconst nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));\r\nfunction removeNonTranslationalTransform(visualElement) {\r\n    const removedTransforms = [];\r\n    nonTranslationalTransformKeys.forEach((key) => {\r\n        const value = visualElement.getValue(key);\r\n        if (value !== undefined) {\r\n            removedTransforms.push([key, value.get()]);\r\n            value.set(key.startsWith(\"scale\") ? 1 : 0);\r\n        }\r\n    });\r\n    // Apply changes to element before measurement\r\n    if (removedTransforms.length)\r\n        visualElement.syncRender();\r\n    return removedTransforms;\r\n}\r\nconst positionalValues = {\r\n    // Dimensions\r\n    width: ({ x }, { paddingLeft = \"0\", paddingRight = \"0\" }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),\r\n    height: ({ y }, { paddingTop = \"0\", paddingBottom = \"0\" }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),\r\n    top: (_bbox, { top }) => parseFloat(top),\r\n    left: (_bbox, { left }) => parseFloat(left),\r\n    bottom: ({ y }, { top }) => parseFloat(top) + (y.max - y.min),\r\n    right: ({ x }, { left }) => parseFloat(left) + (x.max - x.min),\r\n    // Transform\r\n    x: getTranslateFromMatrix(4, 13),\r\n    y: getTranslateFromMatrix(5, 14),\r\n};\r\nconst convertChangedValueTypes = (target, visualElement, changedKeys) => {\r\n    const originBbox = visualElement.measureViewportBox();\r\n    const element = visualElement.getInstance();\r\n    const elementComputedStyle = getComputedStyle(element);\r\n    const { display } = elementComputedStyle;\r\n    const origin = {};\r\n    // If the element is currently set to display: \"none\", make it visible before\r\n    // measuring the target bounding box\r\n    if (display === \"none\") {\r\n        visualElement.setStaticValue(\"display\", target.display || \"block\");\r\n    }\r\n    /**\r\n     * Record origins before we render and update styles\r\n     */\r\n    changedKeys.forEach((key) => {\r\n        origin[key] = positionalValues[key](originBbox, elementComputedStyle);\r\n    });\r\n    // Apply the latest values (as set in checkAndConvertChangedValueTypes)\r\n    visualElement.syncRender();\r\n    const targetBbox = visualElement.measureViewportBox();\r\n    changedKeys.forEach((key) => {\r\n        // Restore styles to their **calculated computed style**, not their actual\r\n        // originally set style. This allows us to animate between equivalent pixel units.\r\n        const value = visualElement.getValue(key);\r\n        setAndResetVelocity(value, origin[key]);\r\n        target[key] = positionalValues[key](targetBbox, elementComputedStyle);\r\n    });\r\n    return target;\r\n};\r\nconst checkAndConvertChangedValueTypes = (visualElement, target, origin = {}, transitionEnd = {}) => {\r\n    target = { ...target };\r\n    transitionEnd = { ...transitionEnd };\r\n    const targetPositionalKeys = Object.keys(target).filter(isPositionalKey);\r\n    // We want to remove any transform values that could affect the element's bounding box before\r\n    // it's measured. We'll reapply these later.\r\n    let removedTransformValues = [];\r\n    let hasAttemptedToRemoveTransformValues = false;\r\n    const changedValueTypeKeys = [];\r\n    targetPositionalKeys.forEach((key) => {\r\n        const value = visualElement.getValue(key);\r\n        if (!visualElement.hasValue(key))\r\n            return;\r\n        let from = origin[key];\r\n        let fromType = findDimensionValueType(from);\r\n        const to = target[key];\r\n        let toType;\r\n        // TODO: The current implementation of this basically throws an error\r\n        // if you try and do value conversion via keyframes. There's probably\r\n        // a way of doing this but the performance implications would need greater scrutiny,\r\n        // as it'd be doing multiple resize-remeasure operations.\r\n        if (isKeyframesTarget(to)) {\r\n            const numKeyframes = to.length;\r\n            const fromIndex = to[0] === null ? 1 : 0;\r\n            from = to[fromIndex];\r\n            fromType = findDimensionValueType(from);\r\n            for (let i = fromIndex; i < numKeyframes; i++) {\r\n                if (!toType) {\r\n                    toType = findDimensionValueType(to[i]);\r\n                    invariant(toType === fromType ||\r\n                        (isNumOrPxType(fromType) && isNumOrPxType(toType)), \"Keyframes must be of the same dimension as the current value\");\r\n                }\r\n                else {\r\n                    invariant(findDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            toType = findDimensionValueType(to);\r\n        }\r\n        if (fromType !== toType) {\r\n            // If they're both just number or px, convert them both to numbers rather than\r\n            // relying on resize/remeasure to convert (which is wasteful in this situation)\r\n            if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\r\n                const current = value.get();\r\n                if (typeof current === \"string\") {\r\n                    value.set(parseFloat(current));\r\n                }\r\n                if (typeof to === \"string\") {\r\n                    target[key] = parseFloat(to);\r\n                }\r\n                else if (Array.isArray(to) && toType === px) {\r\n                    target[key] = to.map(parseFloat);\r\n                }\r\n            }\r\n            else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) &&\r\n                (toType === null || toType === void 0 ? void 0 : toType.transform) &&\r\n                (from === 0 || to === 0)) {\r\n                // If one or the other value is 0, it's safe to coerce it to the\r\n                // type of the other without measurement\r\n                if (from === 0) {\r\n                    value.set(toType.transform(from));\r\n                }\r\n                else {\r\n                    target[key] = fromType.transform(to);\r\n                }\r\n            }\r\n            else {\r\n                // If we're going to do value conversion via DOM measurements, we first\r\n                // need to remove non-positional transform values that could affect the bbox measurements.\r\n                if (!hasAttemptedToRemoveTransformValues) {\r\n                    removedTransformValues =\r\n                        removeNonTranslationalTransform(visualElement);\r\n                    hasAttemptedToRemoveTransformValues = true;\r\n                }\r\n                changedValueTypeKeys.push(key);\r\n                transitionEnd[key] =\r\n                    transitionEnd[key] !== undefined\r\n                        ? transitionEnd[key]\r\n                        : target[key];\r\n                setAndResetVelocity(value, to);\r\n            }\r\n        }\r\n    });\r\n    if (changedValueTypeKeys.length) {\r\n        const scrollY = changedValueTypeKeys.indexOf(\"height\") >= 0\r\n            ? window.pageYOffset\r\n            : null;\r\n        const convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);\r\n        // If we removed transform values, reapply them before the next render\r\n        if (removedTransformValues.length) {\r\n            removedTransformValues.forEach(([key, value]) => {\r\n                visualElement.getValue(key).set(value);\r\n            });\r\n        }\r\n        // Reapply original values\r\n        visualElement.syncRender();\r\n        // Restore scroll position\r\n        if (isBrowser && scrollY !== null) {\r\n            window.scrollTo({ top: scrollY });\r\n        }\r\n        return { target: convertedTarget, transitionEnd };\r\n    }\r\n    else {\r\n        return { target, transitionEnd };\r\n    }\r\n};\r\n/**\r\n * Convert value types for x/y/width/height/top/left/bottom/right\r\n *\r\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\r\n *\r\n * @internal\r\n */\r\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\r\n    return hasPositionalKey(target)\r\n        ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd)\r\n        : { target, transitionEnd };\r\n}\r\n\r\nexport { BoundingBoxDimension, positionalValues, unitConversion };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}