{"ast":null,"code":"import { __rest } from 'tslib';\nimport { findSpring, calcAngularFreq } from '../utils/find-spring.mjs';\nvar durationKeys = [\"duration\", \"bounce\"];\nvar physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\n\nfunction isSpringType(options, keys) {\n  return keys.some(function (key) {\n    return options[key] !== undefined;\n  });\n}\n\nfunction getSpringOptions(options) {\n  var springOptions = Object.assign({\n    velocity: 0.0,\n    stiffness: 100,\n    damping: 10,\n    mass: 1.0,\n    isResolvedFromDuration: false\n  }, options);\n\n  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {\n    var derived = findSpring(options);\n    springOptions = Object.assign(Object.assign(Object.assign({}, springOptions), derived), {\n      velocity: 0.0,\n      mass: 1.0\n    });\n    springOptions.isResolvedFromDuration = true;\n  }\n\n  return springOptions;\n}\n\nfunction spring(_a) {\n  var _a$from = _a.from,\n      from = _a$from === void 0 ? 0.0 : _a$from,\n      _a$to = _a.to,\n      to = _a$to === void 0 ? 1.0 : _a$to,\n      _a$restSpeed = _a.restSpeed,\n      restSpeed = _a$restSpeed === void 0 ? 2 : _a$restSpeed,\n      restDelta = _a.restDelta,\n      options = __rest(_a, [\"from\", \"to\", \"restSpeed\", \"restDelta\"]);\n\n  var state = {\n    done: false,\n    value: from\n  };\n\n  var _getSpringOptions = getSpringOptions(options),\n      stiffness = _getSpringOptions.stiffness,\n      damping = _getSpringOptions.damping,\n      mass = _getSpringOptions.mass,\n      velocity = _getSpringOptions.velocity,\n      duration = _getSpringOptions.duration,\n      isResolvedFromDuration = _getSpringOptions.isResolvedFromDuration;\n\n  var resolveSpring = zero;\n  var resolveVelocity = zero;\n\n  function createSpring() {\n    var initialVelocity = velocity ? -(velocity / 1000) : 0.0;\n    var initialDelta = to - from;\n    var dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n    var undampedAngularFreq = Math.sqrt(stiffness / mass) / 1000;\n\n    if (restDelta === undefined) {\n      restDelta = Math.min(Math.abs(to - from) / 100, 0.4);\n    }\n\n    if (dampingRatio < 1) {\n      var angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n\n      resolveSpring = function resolveSpring(t) {\n        var envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));\n      };\n\n      resolveVelocity = function resolveVelocity(t) {\n        var envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n        return dampingRatio * undampedAngularFreq * envelope * (Math.sin(angularFreq * t) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq + initialDelta * Math.cos(angularFreq * t)) - envelope * (Math.cos(angularFreq * t) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) - angularFreq * initialDelta * Math.sin(angularFreq * t));\n      };\n    } else if (dampingRatio === 1) {\n      resolveSpring = function resolveSpring(t) {\n        return to - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);\n      };\n    } else {\n      var dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n\n      resolveSpring = function resolveSpring(t) {\n        var envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n        var freqForT = Math.min(dampedAngularFreq * t, 300);\n        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;\n      };\n    }\n  }\n\n  createSpring();\n  return {\n    next: function next(t) {\n      var current = resolveSpring(t);\n\n      if (!isResolvedFromDuration) {\n        var currentVelocity = resolveVelocity(t) * 1000;\n        var isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n        var isBelowDisplacementThreshold = Math.abs(to - current) <= restDelta;\n        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;\n      } else {\n        state.done = t >= duration;\n      }\n\n      state.value = state.done ? to : current;\n      return state;\n    },\n    flipTarget: function flipTarget() {\n      velocity = -velocity;\n      var _ref = [to, from];\n      from = _ref[0];\n      to = _ref[1];\n      createSpring();\n    }\n  };\n}\n\nspring.needsInterpolation = function (a, b) {\n  return typeof a === \"string\" || typeof b === \"string\";\n};\n\nvar zero = function zero(_t) {\n  return 0;\n};\n\nexport { spring };","map":{"version":3,"names":["__rest","findSpring","calcAngularFreq","durationKeys","physicsKeys","isSpringType","options","keys","some","key","undefined","getSpringOptions","springOptions","Object","assign","velocity","stiffness","damping","mass","isResolvedFromDuration","derived","spring","_a","from","to","restSpeed","restDelta","state","done","value","duration","resolveSpring","zero","resolveVelocity","createSpring","initialVelocity","initialDelta","dampingRatio","Math","sqrt","undampedAngularFreq","min","abs","angularFreq","t","envelope","exp","sin","cos","dampedAngularFreq","freqForT","sinh","cosh","next","current","currentVelocity","isBelowVelocityThreshold","isBelowDisplacementThreshold","flipTarget","needsInterpolation","a","b","_t"],"sources":["C:/JZ/code/Hack-the-North/frontend/node_modules/popmotion/dist/es/animations/generators/spring.mjs"],"sourcesContent":["import { __rest } from 'tslib';\r\nimport { findSpring, calcAngularFreq } from '../utils/find-spring.mjs';\r\n\r\nconst durationKeys = [\"duration\", \"bounce\"];\r\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\r\nfunction isSpringType(options, keys) {\r\n    return keys.some((key) => options[key] !== undefined);\r\n}\r\nfunction getSpringOptions(options) {\r\n    let springOptions = Object.assign({ velocity: 0.0, stiffness: 100, damping: 10, mass: 1.0, isResolvedFromDuration: false }, options);\r\n    if (!isSpringType(options, physicsKeys) &&\r\n        isSpringType(options, durationKeys)) {\r\n        const derived = findSpring(options);\r\n        springOptions = Object.assign(Object.assign(Object.assign({}, springOptions), derived), { velocity: 0.0, mass: 1.0 });\r\n        springOptions.isResolvedFromDuration = true;\r\n    }\r\n    return springOptions;\r\n}\r\nfunction spring(_a) {\r\n    var { from = 0.0, to = 1.0, restSpeed = 2, restDelta } = _a, options = __rest(_a, [\"from\", \"to\", \"restSpeed\", \"restDelta\"]);\r\n    const state = { done: false, value: from };\r\n    let { stiffness, damping, mass, velocity, duration, isResolvedFromDuration, } = getSpringOptions(options);\r\n    let resolveSpring = zero;\r\n    let resolveVelocity = zero;\r\n    function createSpring() {\r\n        const initialVelocity = velocity ? -(velocity / 1000) : 0.0;\r\n        const initialDelta = to - from;\r\n        const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\r\n        const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1000;\r\n        if (restDelta === undefined) {\r\n            restDelta = Math.min(Math.abs(to - from) / 100, 0.4);\r\n        }\r\n        if (dampingRatio < 1) {\r\n            const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\r\n            resolveSpring = (t) => {\r\n                const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\r\n                return (to -\r\n                    envelope *\r\n                        (((initialVelocity +\r\n                            dampingRatio * undampedAngularFreq * initialDelta) /\r\n                            angularFreq) *\r\n                            Math.sin(angularFreq * t) +\r\n                            initialDelta * Math.cos(angularFreq * t)));\r\n            };\r\n            resolveVelocity = (t) => {\r\n                const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\r\n                return (dampingRatio *\r\n                    undampedAngularFreq *\r\n                    envelope *\r\n                    ((Math.sin(angularFreq * t) *\r\n                        (initialVelocity +\r\n                            dampingRatio *\r\n                                undampedAngularFreq *\r\n                                initialDelta)) /\r\n                        angularFreq +\r\n                        initialDelta * Math.cos(angularFreq * t)) -\r\n                    envelope *\r\n                        (Math.cos(angularFreq * t) *\r\n                            (initialVelocity +\r\n                                dampingRatio *\r\n                                    undampedAngularFreq *\r\n                                    initialDelta) -\r\n                            angularFreq *\r\n                                initialDelta *\r\n                                Math.sin(angularFreq * t)));\r\n            };\r\n        }\r\n        else if (dampingRatio === 1) {\r\n            resolveSpring = (t) => to -\r\n                Math.exp(-undampedAngularFreq * t) *\r\n                    (initialDelta +\r\n                        (initialVelocity + undampedAngularFreq * initialDelta) *\r\n                            t);\r\n        }\r\n        else {\r\n            const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\r\n            resolveSpring = (t) => {\r\n                const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\r\n                const freqForT = Math.min(dampedAngularFreq * t, 300);\r\n                return (to -\r\n                    (envelope *\r\n                        ((initialVelocity +\r\n                            dampingRatio * undampedAngularFreq * initialDelta) *\r\n                            Math.sinh(freqForT) +\r\n                            dampedAngularFreq *\r\n                                initialDelta *\r\n                                Math.cosh(freqForT))) /\r\n                        dampedAngularFreq);\r\n            };\r\n        }\r\n    }\r\n    createSpring();\r\n    return {\r\n        next: (t) => {\r\n            const current = resolveSpring(t);\r\n            if (!isResolvedFromDuration) {\r\n                const currentVelocity = resolveVelocity(t) * 1000;\r\n                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\r\n                const isBelowDisplacementThreshold = Math.abs(to - current) <= restDelta;\r\n                state.done =\r\n                    isBelowVelocityThreshold && isBelowDisplacementThreshold;\r\n            }\r\n            else {\r\n                state.done = t >= duration;\r\n            }\r\n            state.value = state.done ? to : current;\r\n            return state;\r\n        },\r\n        flipTarget: () => {\r\n            velocity = -velocity;\r\n            [from, to] = [to, from];\r\n            createSpring();\r\n        },\r\n    };\r\n}\r\nspring.needsInterpolation = (a, b) => typeof a === \"string\" || typeof b === \"string\";\r\nconst zero = (_t) => 0;\r\n\r\nexport { spring };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}