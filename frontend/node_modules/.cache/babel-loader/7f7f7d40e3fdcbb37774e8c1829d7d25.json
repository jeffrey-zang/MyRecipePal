{"ast":null,"code":"import { mix, progress, circOut, linear } from 'popmotion';\nimport { percent, px } from 'style-value-types';\nconst borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\nconst numBorders = borders.length;\n\nconst asNumber = value => typeof value === \"string\" ? parseFloat(value) : value;\n\nconst isPx = value => typeof value === \"number\" || px.test(value);\n\nfunction mixValues(target, follow, lead, progress, shouldCrossfadeOpacity, isOnlyMember) {\n  var _a, _b, _c, _d;\n\n  if (shouldCrossfadeOpacity) {\n    target.opacity = mix(0, // (follow?.opacity as number) ?? 0,\n    // TODO Reinstate this if only child\n    (_a = lead.opacity) !== null && _a !== void 0 ? _a : 1, easeCrossfadeIn(progress));\n    target.opacityExit = mix((_b = follow.opacity) !== null && _b !== void 0 ? _b : 1, 0, easeCrossfadeOut(progress));\n  } else if (isOnlyMember) {\n    target.opacity = mix((_c = follow.opacity) !== null && _c !== void 0 ? _c : 1, (_d = lead.opacity) !== null && _d !== void 0 ? _d : 1, progress);\n  }\n  /**\r\n   * Mix border radius\r\n   */\n\n\n  for (let i = 0; i < numBorders; i++) {\n    const borderLabel = `border${borders[i]}Radius`;\n    let followRadius = getRadius(follow, borderLabel);\n    let leadRadius = getRadius(lead, borderLabel);\n    if (followRadius === undefined && leadRadius === undefined) continue;\n    followRadius || (followRadius = 0);\n    leadRadius || (leadRadius = 0);\n    const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);\n\n    if (canMix) {\n      target[borderLabel] = Math.max(mix(asNumber(followRadius), asNumber(leadRadius), progress), 0);\n\n      if (percent.test(leadRadius) || percent.test(followRadius)) {\n        target[borderLabel] += \"%\";\n      }\n    } else {\n      target[borderLabel] = leadRadius;\n    }\n  }\n  /**\r\n   * Mix rotation\r\n   */\n\n\n  if (follow.rotate || lead.rotate) {\n    target.rotate = mix(follow.rotate || 0, lead.rotate || 0, progress);\n  }\n}\n\nfunction getRadius(values, radiusName) {\n  var _a;\n\n  return (_a = values[radiusName]) !== null && _a !== void 0 ? _a : values.borderRadius;\n} // /**\n//  * We only want to mix the background color if there's a follow element\n//  * that we're not crossfading opacity between. For instance with switch\n//  * AnimateSharedLayout animations, this helps the illusion of a continuous\n//  * element being animated but also cuts down on the number of paints triggered\n//  * for elements where opacity is doing that work for us.\n//  */\n// if (\n//     !hasFollowElement &&\n//     latestLeadValues.backgroundColor &&\n//     latestFollowValues.backgroundColor\n// ) {\n//     /**\n//      * This isn't ideal performance-wise as mixColor is creating a new function every frame.\n//      * We could probably create a mixer that runs at the start of the animation but\n//      * the idea behind the crossfader is that it runs dynamically between two potentially\n//      * changing targets (ie opacity or borderRadius may be animating independently via variants)\n//      */\n//     leadState.backgroundColor = followState.backgroundColor = mixColor(\n//         latestFollowValues.backgroundColor as string,\n//         latestLeadValues.backgroundColor as string\n//     )(p)\n// }\n\n\nconst easeCrossfadeIn = compress(0, 0.5, circOut);\nconst easeCrossfadeOut = compress(0.5, 0.95, linear);\n\nfunction compress(min, max, easing) {\n  return p => {\n    // Could replace ifs with clamp\n    if (p < min) return 0;\n    if (p > max) return 1;\n    return easing(progress(min, max, p));\n  };\n}\n\nexport { mixValues };","map":{"version":3,"names":["mix","progress","circOut","linear","percent","px","borders","numBorders","length","asNumber","value","parseFloat","isPx","test","mixValues","target","follow","lead","shouldCrossfadeOpacity","isOnlyMember","_a","_b","_c","_d","opacity","easeCrossfadeIn","opacityExit","easeCrossfadeOut","i","borderLabel","followRadius","getRadius","leadRadius","undefined","canMix","Math","max","rotate","values","radiusName","borderRadius","compress","min","easing","p"],"sources":["C:/JZ/code/Hack-the-North/frontend/node_modules/framer-motion/dist/es/projection/animation/mix-values.mjs"],"sourcesContent":["import { mix, progress, circOut, linear } from 'popmotion';\r\nimport { percent, px } from 'style-value-types';\r\n\r\nconst borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\r\nconst numBorders = borders.length;\r\nconst asNumber = (value) => typeof value === \"string\" ? parseFloat(value) : value;\r\nconst isPx = (value) => typeof value === \"number\" || px.test(value);\r\nfunction mixValues(target, follow, lead, progress, shouldCrossfadeOpacity, isOnlyMember) {\r\n    var _a, _b, _c, _d;\r\n    if (shouldCrossfadeOpacity) {\r\n        target.opacity = mix(0, \r\n        // (follow?.opacity as number) ?? 0,\r\n        // TODO Reinstate this if only child\r\n        (_a = lead.opacity) !== null && _a !== void 0 ? _a : 1, easeCrossfadeIn(progress));\r\n        target.opacityExit = mix((_b = follow.opacity) !== null && _b !== void 0 ? _b : 1, 0, easeCrossfadeOut(progress));\r\n    }\r\n    else if (isOnlyMember) {\r\n        target.opacity = mix((_c = follow.opacity) !== null && _c !== void 0 ? _c : 1, (_d = lead.opacity) !== null && _d !== void 0 ? _d : 1, progress);\r\n    }\r\n    /**\r\n     * Mix border radius\r\n     */\r\n    for (let i = 0; i < numBorders; i++) {\r\n        const borderLabel = `border${borders[i]}Radius`;\r\n        let followRadius = getRadius(follow, borderLabel);\r\n        let leadRadius = getRadius(lead, borderLabel);\r\n        if (followRadius === undefined && leadRadius === undefined)\r\n            continue;\r\n        followRadius || (followRadius = 0);\r\n        leadRadius || (leadRadius = 0);\r\n        const canMix = followRadius === 0 ||\r\n            leadRadius === 0 ||\r\n            isPx(followRadius) === isPx(leadRadius);\r\n        if (canMix) {\r\n            target[borderLabel] = Math.max(mix(asNumber(followRadius), asNumber(leadRadius), progress), 0);\r\n            if (percent.test(leadRadius) || percent.test(followRadius)) {\r\n                target[borderLabel] += \"%\";\r\n            }\r\n        }\r\n        else {\r\n            target[borderLabel] = leadRadius;\r\n        }\r\n    }\r\n    /**\r\n     * Mix rotation\r\n     */\r\n    if (follow.rotate || lead.rotate) {\r\n        target.rotate = mix(follow.rotate || 0, lead.rotate || 0, progress);\r\n    }\r\n}\r\nfunction getRadius(values, radiusName) {\r\n    var _a;\r\n    return (_a = values[radiusName]) !== null && _a !== void 0 ? _a : values.borderRadius;\r\n}\r\n// /**\r\n//  * We only want to mix the background color if there's a follow element\r\n//  * that we're not crossfading opacity between. For instance with switch\r\n//  * AnimateSharedLayout animations, this helps the illusion of a continuous\r\n//  * element being animated but also cuts down on the number of paints triggered\r\n//  * for elements where opacity is doing that work for us.\r\n//  */\r\n// if (\r\n//     !hasFollowElement &&\r\n//     latestLeadValues.backgroundColor &&\r\n//     latestFollowValues.backgroundColor\r\n// ) {\r\n//     /**\r\n//      * This isn't ideal performance-wise as mixColor is creating a new function every frame.\r\n//      * We could probably create a mixer that runs at the start of the animation but\r\n//      * the idea behind the crossfader is that it runs dynamically between two potentially\r\n//      * changing targets (ie opacity or borderRadius may be animating independently via variants)\r\n//      */\r\n//     leadState.backgroundColor = followState.backgroundColor = mixColor(\r\n//         latestFollowValues.backgroundColor as string,\r\n//         latestLeadValues.backgroundColor as string\r\n//     )(p)\r\n// }\r\nconst easeCrossfadeIn = compress(0, 0.5, circOut);\r\nconst easeCrossfadeOut = compress(0.5, 0.95, linear);\r\nfunction compress(min, max, easing) {\r\n    return (p) => {\r\n        // Could replace ifs with clamp\r\n        if (p < min)\r\n            return 0;\r\n        if (p > max)\r\n            return 1;\r\n        return easing(progress(min, max, p));\r\n    };\r\n}\r\n\r\nexport { mixValues };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}