{"ast":null,"code":"import { visualElement } from '../index.mjs';\nimport { getOrigin, checkTargetForNewValues } from '../utils/setters.mjs';\nimport { buildHTMLStyles } from './utils/build-styles.mjs';\nimport { isCSSVariable } from '../dom/utils/is-css-variable.mjs';\nimport { parseDomVariant } from '../dom/utils/parse-dom-variant.mjs';\nimport { transformProps } from './utils/transform.mjs';\nimport { scrapeMotionValuesFromProps } from './utils/scrape-motion-values.mjs';\nimport { renderHTML } from './utils/render.mjs';\nimport { getDefaultValueType } from '../dom/value-types/defaults.mjs';\nimport { measureViewportBox } from '../../projection/utils/measure.mjs';\n\nfunction getComputedStyle(element) {\n  return window.getComputedStyle(element);\n}\n\nconst htmlConfig = {\n  treeType: \"dom\",\n\n  readValueFromInstance(domElement, key) {\n    if (transformProps.has(key)) {\n      const defaultType = getDefaultValueType(key);\n      return defaultType ? defaultType.default || 0 : 0;\n    } else {\n      const computedStyle = getComputedStyle(domElement);\n      const value = (isCSSVariable(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;\n      return typeof value === \"string\" ? value.trim() : value;\n    }\n  },\n\n  sortNodePosition(a, b) {\n    /**\n     * compareDocumentPosition returns a bitmask, by using the bitwise &\n     * we're returning true if 2 in that bitmask is set to true. 2 is set\n     * to true if b preceeds a.\n     */\n    return a.compareDocumentPosition(b) & 2 ? 1 : -1;\n  },\n\n  getBaseTarget(props, key) {\n    var _a;\n\n    return (_a = props.style) === null || _a === void 0 ? void 0 : _a[key];\n  },\n\n  measureViewportBox(element, _ref) {\n    let {\n      transformPagePoint\n    } = _ref;\n    return measureViewportBox(element, transformPagePoint);\n  },\n\n  /**\n   * Reset the transform on the current Element. This is called as part\n   * of a batched process across the entire layout tree. To remove this write\n   * cycle it'd be interesting to see if it's possible to \"undo\" all the current\n   * layout transforms up the tree in the same way this.getBoundingBoxWithoutTransforms\n   * works\n   */\n  resetTransform(element, domElement, props) {\n    const {\n      transformTemplate\n    } = props;\n    domElement.style.transform = transformTemplate ? transformTemplate({}, \"\") : \"none\"; // Ensure that whatever happens next, we restore our transform on the next frame\n\n    element.scheduleRender();\n  },\n\n  restoreTransform(instance, mutableState) {\n    instance.style.transform = mutableState.style.transform;\n  },\n\n  removeValueFromRenderState(key, _ref2) {\n    let {\n      vars,\n      style\n    } = _ref2;\n    delete vars[key];\n    delete style[key];\n  },\n\n  /**\n   * Ensure that HTML and Framer-specific value types like `px`->`%` and `Color`\n   * can be animated by Motion.\n   */\n  makeTargetAnimatable(element, _ref3, _ref4) {\n    let {\n      transition,\n      transitionEnd,\n      ...target\n    } = _ref3;\n    let {\n      transformValues\n    } = _ref4;\n    let isMounted = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    let origin = getOrigin(target, transition || {}, element);\n    /**\n     * If Framer has provided a function to convert `Color` etc value types, convert them\n     */\n\n    if (transformValues) {\n      if (transitionEnd) transitionEnd = transformValues(transitionEnd);\n      if (target) target = transformValues(target);\n      if (origin) origin = transformValues(origin);\n    }\n\n    if (isMounted) {\n      checkTargetForNewValues(element, target, origin);\n      const parsed = parseDomVariant(element, target, origin, transitionEnd);\n      transitionEnd = parsed.transitionEnd;\n      target = parsed.target;\n    }\n\n    return {\n      transition,\n      transitionEnd,\n      ...target\n    };\n  },\n\n  scrapeMotionValuesFromProps,\n\n  build(element, renderState, latestValues, options, props) {\n    if (element.isVisible !== undefined) {\n      renderState.style.visibility = element.isVisible ? \"visible\" : \"hidden\";\n    }\n\n    buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);\n  },\n\n  render: renderHTML\n};\nconst htmlVisualElement = visualElement(htmlConfig);\nexport { getComputedStyle, htmlConfig, htmlVisualElement };","map":{"version":3,"names":["visualElement","getOrigin","checkTargetForNewValues","buildHTMLStyles","isCSSVariable","parseDomVariant","transformProps","scrapeMotionValuesFromProps","renderHTML","getDefaultValueType","measureViewportBox","getComputedStyle","element","window","htmlConfig","treeType","readValueFromInstance","domElement","key","has","defaultType","default","computedStyle","value","getPropertyValue","trim","sortNodePosition","a","b","compareDocumentPosition","getBaseTarget","props","_a","style","transformPagePoint","resetTransform","transformTemplate","transform","scheduleRender","restoreTransform","instance","mutableState","removeValueFromRenderState","vars","makeTargetAnimatable","transition","transitionEnd","target","transformValues","isMounted","origin","parsed","build","renderState","latestValues","options","isVisible","undefined","visibility","render","htmlVisualElement"],"sources":["/Users/dan/Desktop/Hack-the-North/frontend/node_modules/framer-motion/dist/es/render/html/visual-element.mjs"],"sourcesContent":["import { visualElement } from '../index.mjs';\nimport { getOrigin, checkTargetForNewValues } from '../utils/setters.mjs';\nimport { buildHTMLStyles } from './utils/build-styles.mjs';\nimport { isCSSVariable } from '../dom/utils/is-css-variable.mjs';\nimport { parseDomVariant } from '../dom/utils/parse-dom-variant.mjs';\nimport { transformProps } from './utils/transform.mjs';\nimport { scrapeMotionValuesFromProps } from './utils/scrape-motion-values.mjs';\nimport { renderHTML } from './utils/render.mjs';\nimport { getDefaultValueType } from '../dom/value-types/defaults.mjs';\nimport { measureViewportBox } from '../../projection/utils/measure.mjs';\n\nfunction getComputedStyle(element) {\n    return window.getComputedStyle(element);\n}\nconst htmlConfig = {\n    treeType: \"dom\",\n    readValueFromInstance(domElement, key) {\n        if (transformProps.has(key)) {\n            const defaultType = getDefaultValueType(key);\n            return defaultType ? defaultType.default || 0 : 0;\n        }\n        else {\n            const computedStyle = getComputedStyle(domElement);\n            const value = (isCSSVariable(key)\n                ? computedStyle.getPropertyValue(key)\n                : computedStyle[key]) || 0;\n            return typeof value === \"string\" ? value.trim() : value;\n        }\n    },\n    sortNodePosition(a, b) {\n        /**\n         * compareDocumentPosition returns a bitmask, by using the bitwise &\n         * we're returning true if 2 in that bitmask is set to true. 2 is set\n         * to true if b preceeds a.\n         */\n        return a.compareDocumentPosition(b) & 2 ? 1 : -1;\n    },\n    getBaseTarget(props, key) {\n        var _a;\n        return (_a = props.style) === null || _a === void 0 ? void 0 : _a[key];\n    },\n    measureViewportBox(element, { transformPagePoint }) {\n        return measureViewportBox(element, transformPagePoint);\n    },\n    /**\n     * Reset the transform on the current Element. This is called as part\n     * of a batched process across the entire layout tree. To remove this write\n     * cycle it'd be interesting to see if it's possible to \"undo\" all the current\n     * layout transforms up the tree in the same way this.getBoundingBoxWithoutTransforms\n     * works\n     */\n    resetTransform(element, domElement, props) {\n        const { transformTemplate } = props;\n        domElement.style.transform = transformTemplate\n            ? transformTemplate({}, \"\")\n            : \"none\";\n        // Ensure that whatever happens next, we restore our transform on the next frame\n        element.scheduleRender();\n    },\n    restoreTransform(instance, mutableState) {\n        instance.style.transform = mutableState.style.transform;\n    },\n    removeValueFromRenderState(key, { vars, style }) {\n        delete vars[key];\n        delete style[key];\n    },\n    /**\n     * Ensure that HTML and Framer-specific value types like `px`->`%` and `Color`\n     * can be animated by Motion.\n     */\n    makeTargetAnimatable(element, { transition, transitionEnd, ...target }, { transformValues }, isMounted = true) {\n        let origin = getOrigin(target, transition || {}, element);\n        /**\n         * If Framer has provided a function to convert `Color` etc value types, convert them\n         */\n        if (transformValues) {\n            if (transitionEnd)\n                transitionEnd = transformValues(transitionEnd);\n            if (target)\n                target = transformValues(target);\n            if (origin)\n                origin = transformValues(origin);\n        }\n        if (isMounted) {\n            checkTargetForNewValues(element, target, origin);\n            const parsed = parseDomVariant(element, target, origin, transitionEnd);\n            transitionEnd = parsed.transitionEnd;\n            target = parsed.target;\n        }\n        return {\n            transition,\n            transitionEnd,\n            ...target,\n        };\n    },\n    scrapeMotionValuesFromProps,\n    build(element, renderState, latestValues, options, props) {\n        if (element.isVisible !== undefined) {\n            renderState.style.visibility = element.isVisible\n                ? \"visible\"\n                : \"hidden\";\n        }\n        buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);\n    },\n    render: renderHTML,\n};\nconst htmlVisualElement = visualElement(htmlConfig);\n\nexport { getComputedStyle, htmlConfig, htmlVisualElement };\n"],"mappings":"AAAA,SAASA,aAAT,QAA8B,cAA9B;AACA,SAASC,SAAT,EAAoBC,uBAApB,QAAmD,sBAAnD;AACA,SAASC,eAAT,QAAgC,0BAAhC;AACA,SAASC,aAAT,QAA8B,kCAA9B;AACA,SAASC,eAAT,QAAgC,oCAAhC;AACA,SAASC,cAAT,QAA+B,uBAA/B;AACA,SAASC,2BAAT,QAA4C,kCAA5C;AACA,SAASC,UAAT,QAA2B,oBAA3B;AACA,SAASC,mBAAT,QAAoC,iCAApC;AACA,SAASC,kBAAT,QAAmC,oCAAnC;;AAEA,SAASC,gBAAT,CAA0BC,OAA1B,EAAmC;EAC/B,OAAOC,MAAM,CAACF,gBAAP,CAAwBC,OAAxB,CAAP;AACH;;AACD,MAAME,UAAU,GAAG;EACfC,QAAQ,EAAE,KADK;;EAEfC,qBAAqB,CAACC,UAAD,EAAaC,GAAb,EAAkB;IACnC,IAAIZ,cAAc,CAACa,GAAf,CAAmBD,GAAnB,CAAJ,EAA6B;MACzB,MAAME,WAAW,GAAGX,mBAAmB,CAACS,GAAD,CAAvC;MACA,OAAOE,WAAW,GAAGA,WAAW,CAACC,OAAZ,IAAuB,CAA1B,GAA8B,CAAhD;IACH,CAHD,MAIK;MACD,MAAMC,aAAa,GAAGX,gBAAgB,CAACM,UAAD,CAAtC;MACA,MAAMM,KAAK,GAAG,CAACnB,aAAa,CAACc,GAAD,CAAb,GACTI,aAAa,CAACE,gBAAd,CAA+BN,GAA/B,CADS,GAETI,aAAa,CAACJ,GAAD,CAFL,KAEe,CAF7B;MAGA,OAAO,OAAOK,KAAP,KAAiB,QAAjB,GAA4BA,KAAK,CAACE,IAAN,EAA5B,GAA2CF,KAAlD;IACH;EACJ,CAdc;;EAefG,gBAAgB,CAACC,CAAD,EAAIC,CAAJ,EAAO;IACnB;AACR;AACA;AACA;AACA;IACQ,OAAOD,CAAC,CAACE,uBAAF,CAA0BD,CAA1B,IAA+B,CAA/B,GAAmC,CAAnC,GAAuC,CAAC,CAA/C;EACH,CAtBc;;EAuBfE,aAAa,CAACC,KAAD,EAAQb,GAAR,EAAa;IACtB,IAAIc,EAAJ;;IACA,OAAO,CAACA,EAAE,GAAGD,KAAK,CAACE,KAAZ,MAAuB,IAAvB,IAA+BD,EAAE,KAAK,KAAK,CAA3C,GAA+C,KAAK,CAApD,GAAwDA,EAAE,CAACd,GAAD,CAAjE;EACH,CA1Bc;;EA2BfR,kBAAkB,CAACE,OAAD,QAAkC;IAAA,IAAxB;MAAEsB;IAAF,CAAwB;IAChD,OAAOxB,kBAAkB,CAACE,OAAD,EAAUsB,kBAAV,CAAzB;EACH,CA7Bc;;EA8Bf;AACJ;AACA;AACA;AACA;AACA;AACA;EACIC,cAAc,CAACvB,OAAD,EAAUK,UAAV,EAAsBc,KAAtB,EAA6B;IACvC,MAAM;MAAEK;IAAF,IAAwBL,KAA9B;IACAd,UAAU,CAACgB,KAAX,CAAiBI,SAAjB,GAA6BD,iBAAiB,GACxCA,iBAAiB,CAAC,EAAD,EAAK,EAAL,CADuB,GAExC,MAFN,CAFuC,CAKvC;;IACAxB,OAAO,CAAC0B,cAAR;EACH,CA5Cc;;EA6CfC,gBAAgB,CAACC,QAAD,EAAWC,YAAX,EAAyB;IACrCD,QAAQ,CAACP,KAAT,CAAeI,SAAf,GAA2BI,YAAY,CAACR,KAAb,CAAmBI,SAA9C;EACH,CA/Cc;;EAgDfK,0BAA0B,CAACxB,GAAD,SAAuB;IAAA,IAAjB;MAAEyB,IAAF;MAAQV;IAAR,CAAiB;IAC7C,OAAOU,IAAI,CAACzB,GAAD,CAAX;IACA,OAAOe,KAAK,CAACf,GAAD,CAAZ;EACH,CAnDc;;EAoDf;AACJ;AACA;AACA;EACI0B,oBAAoB,CAAChC,OAAD,gBAA2F;IAAA,IAAjF;MAAEiC,UAAF;MAAcC,aAAd;MAA6B,GAAGC;IAAhC,CAAiF;IAAA,IAAvC;MAAEC;IAAF,CAAuC;IAAA,IAAlBC,SAAkB,uEAAN,IAAM;IAC3G,IAAIC,MAAM,GAAGjD,SAAS,CAAC8C,MAAD,EAASF,UAAU,IAAI,EAAvB,EAA2BjC,OAA3B,CAAtB;IACA;AACR;AACA;;IACQ,IAAIoC,eAAJ,EAAqB;MACjB,IAAIF,aAAJ,EACIA,aAAa,GAAGE,eAAe,CAACF,aAAD,CAA/B;MACJ,IAAIC,MAAJ,EACIA,MAAM,GAAGC,eAAe,CAACD,MAAD,CAAxB;MACJ,IAAIG,MAAJ,EACIA,MAAM,GAAGF,eAAe,CAACE,MAAD,CAAxB;IACP;;IACD,IAAID,SAAJ,EAAe;MACX/C,uBAAuB,CAACU,OAAD,EAAUmC,MAAV,EAAkBG,MAAlB,CAAvB;MACA,MAAMC,MAAM,GAAG9C,eAAe,CAACO,OAAD,EAAUmC,MAAV,EAAkBG,MAAlB,EAA0BJ,aAA1B,CAA9B;MACAA,aAAa,GAAGK,MAAM,CAACL,aAAvB;MACAC,MAAM,GAAGI,MAAM,CAACJ,MAAhB;IACH;;IACD,OAAO;MACHF,UADG;MAEHC,aAFG;MAGH,GAAGC;IAHA,CAAP;EAKH,CAhFc;;EAiFfxC,2BAjFe;;EAkFf6C,KAAK,CAACxC,OAAD,EAAUyC,WAAV,EAAuBC,YAAvB,EAAqCC,OAArC,EAA8CxB,KAA9C,EAAqD;IACtD,IAAInB,OAAO,CAAC4C,SAAR,KAAsBC,SAA1B,EAAqC;MACjCJ,WAAW,CAACpB,KAAZ,CAAkByB,UAAlB,GAA+B9C,OAAO,CAAC4C,SAAR,GACzB,SADyB,GAEzB,QAFN;IAGH;;IACDrD,eAAe,CAACkD,WAAD,EAAcC,YAAd,EAA4BC,OAA5B,EAAqCxB,KAAK,CAACK,iBAA3C,CAAf;EACH,CAzFc;;EA0FfuB,MAAM,EAAEnD;AA1FO,CAAnB;AA4FA,MAAMoD,iBAAiB,GAAG5D,aAAa,CAACc,UAAD,CAAvC;AAEA,SAASH,gBAAT,EAA2BG,UAA3B,EAAuC8C,iBAAvC"},"metadata":{},"sourceType":"module"}