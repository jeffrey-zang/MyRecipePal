{"ast":null,"code":"import _toConsumableArray from \"C:/JZ/code/Hack-the-North/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectSpread from \"C:/JZ/code/Hack-the-North/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"C:/JZ/code/Hack-the-North/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"transitionEnd\", \"transition\"];\nimport { complex } from 'style-value-types';\nimport { isNumericalString } from '../../utils/is-numerical-string.mjs';\nimport { isZeroValueString } from '../../utils/is-zero-value-string.mjs';\nimport { resolveFinalValueInKeyframes } from '../../utils/resolve-value.mjs';\nimport { motionValue } from '../../value/index.mjs';\nimport { getAnimatableNone } from '../dom/value-types/animatable-none.mjs';\nimport { findValueType } from '../dom/value-types/find.mjs';\nimport { resolveVariant } from './resolve-dynamic-variants.mjs';\n/**\r\n * Set VisualElement's MotionValue, creating a new MotionValue for it if\r\n * it doesn't exist.\r\n */\n\nfunction setMotionValue(visualElement, key, value) {\n  if (visualElement.hasValue(key)) {\n    visualElement.getValue(key).set(value);\n  } else {\n    visualElement.addValue(key, motionValue(value));\n  }\n}\n\nfunction setTarget(visualElement, definition) {\n  var resolved = resolveVariant(visualElement, definition);\n\n  var _ref = resolved ? visualElement.makeTargetAnimatable(resolved, false) : {},\n      _ref$transitionEnd = _ref.transitionEnd,\n      transitionEnd = _ref$transitionEnd === void 0 ? {} : _ref$transitionEnd,\n      _ref$transition = _ref.transition,\n      transition = _ref$transition === void 0 ? {} : _ref$transition,\n      target = _objectWithoutProperties(_ref, _excluded);\n\n  target = _objectSpread(_objectSpread({}, target), transitionEnd);\n\n  for (var key in target) {\n    var value = resolveFinalValueInKeyframes(target[key]);\n    setMotionValue(visualElement, key, value);\n  }\n}\n\nfunction setVariants(visualElement, variantLabels) {\n  var reversedLabels = _toConsumableArray(variantLabels).reverse();\n\n  reversedLabels.forEach(function (key) {\n    var _a;\n\n    var variant = visualElement.getVariant(key);\n    variant && setTarget(visualElement, variant);\n    (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {\n      setVariants(child, variantLabels);\n    });\n  });\n}\n\nfunction setValues(visualElement, definition) {\n  if (Array.isArray(definition)) {\n    return setVariants(visualElement, definition);\n  } else if (typeof definition === \"string\") {\n    return setVariants(visualElement, [definition]);\n  } else {\n    setTarget(visualElement, definition);\n  }\n}\n\nfunction checkTargetForNewValues(visualElement, target, origin) {\n  var _a, _b;\n\n  var newValueKeys = Object.keys(target).filter(function (key) {\n    return !visualElement.hasValue(key);\n  });\n  var numNewValues = newValueKeys.length;\n  if (!numNewValues) return;\n\n  for (var i = 0; i < numNewValues; i++) {\n    var key = newValueKeys[i];\n    var targetValue = target[key];\n    var value = null;\n    /**\r\n     * If the target is a series of keyframes, we can use the first value\r\n     * in the array. If this first value is null, we'll still need to read from the DOM.\r\n     */\n\n    if (Array.isArray(targetValue)) {\n      value = targetValue[0];\n    }\n    /**\r\n     * If the target isn't keyframes, or the first keyframe was null, we need to\r\n     * first check if an origin value was explicitly defined in the transition as \"from\",\r\n     * if not read the value from the DOM. As an absolute fallback, take the defined target value.\r\n     */\n\n\n    if (value === null) {\n      value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement.readValue(key)) !== null && _b !== void 0 ? _b : target[key];\n    }\n    /**\r\n     * If value is still undefined or null, ignore it. Preferably this would throw,\r\n     * but this was causing issues in Framer.\r\n     */\n\n\n    if (value === undefined || value === null) continue;\n\n    if (typeof value === \"string\" && (isNumericalString(value) || isZeroValueString(value))) {\n      // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n      value = parseFloat(value);\n    } else if (!findValueType(value) && complex.test(targetValue)) {\n      value = getAnimatableNone(key, targetValue);\n    }\n\n    visualElement.addValue(key, motionValue(value));\n\n    if (origin[key] === undefined) {\n      origin[key] = value;\n    }\n\n    visualElement.setBaseTarget(key, value);\n  }\n}\n\nfunction getOriginFromTransition(key, transition) {\n  if (!transition) return;\n  var valueTransition = transition[key] || transition[\"default\"] || transition;\n  return valueTransition.from;\n}\n\nfunction getOrigin(target, transition, visualElement) {\n  var _a;\n\n  var origin = {};\n\n  for (var key in target) {\n    var transitionOrigin = getOriginFromTransition(key, transition);\n    origin[key] = transitionOrigin !== undefined ? transitionOrigin : (_a = visualElement.getValue(key)) === null || _a === void 0 ? void 0 : _a.get();\n  }\n\n  return origin;\n}\n\nexport { checkTargetForNewValues, getOrigin, getOriginFromTransition, setTarget, setValues };","map":{"version":3,"names":["complex","isNumericalString","isZeroValueString","resolveFinalValueInKeyframes","motionValue","getAnimatableNone","findValueType","resolveVariant","setMotionValue","visualElement","key","value","hasValue","getValue","set","addValue","setTarget","definition","resolved","makeTargetAnimatable","transitionEnd","transition","target","setVariants","variantLabels","reversedLabels","reverse","forEach","_a","variant","getVariant","variantChildren","child","setValues","Array","isArray","checkTargetForNewValues","origin","_b","newValueKeys","Object","keys","filter","numNewValues","length","i","targetValue","readValue","undefined","parseFloat","test","setBaseTarget","getOriginFromTransition","valueTransition","from","getOrigin","transitionOrigin","get"],"sources":["C:/JZ/code/Hack-the-North/frontend/node_modules/framer-motion/dist/es/render/utils/setters.mjs"],"sourcesContent":["import { complex } from 'style-value-types';\r\nimport { isNumericalString } from '../../utils/is-numerical-string.mjs';\r\nimport { isZeroValueString } from '../../utils/is-zero-value-string.mjs';\r\nimport { resolveFinalValueInKeyframes } from '../../utils/resolve-value.mjs';\r\nimport { motionValue } from '../../value/index.mjs';\r\nimport { getAnimatableNone } from '../dom/value-types/animatable-none.mjs';\r\nimport { findValueType } from '../dom/value-types/find.mjs';\r\nimport { resolveVariant } from './resolve-dynamic-variants.mjs';\r\n\r\n/**\r\n * Set VisualElement's MotionValue, creating a new MotionValue for it if\r\n * it doesn't exist.\r\n */\r\nfunction setMotionValue(visualElement, key, value) {\r\n    if (visualElement.hasValue(key)) {\r\n        visualElement.getValue(key).set(value);\r\n    }\r\n    else {\r\n        visualElement.addValue(key, motionValue(value));\r\n    }\r\n}\r\nfunction setTarget(visualElement, definition) {\r\n    const resolved = resolveVariant(visualElement, definition);\r\n    let { transitionEnd = {}, transition = {}, ...target } = resolved ? visualElement.makeTargetAnimatable(resolved, false) : {};\r\n    target = { ...target, ...transitionEnd };\r\n    for (const key in target) {\r\n        const value = resolveFinalValueInKeyframes(target[key]);\r\n        setMotionValue(visualElement, key, value);\r\n    }\r\n}\r\nfunction setVariants(visualElement, variantLabels) {\r\n    const reversedLabels = [...variantLabels].reverse();\r\n    reversedLabels.forEach((key) => {\r\n        var _a;\r\n        const variant = visualElement.getVariant(key);\r\n        variant && setTarget(visualElement, variant);\r\n        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach((child) => {\r\n            setVariants(child, variantLabels);\r\n        });\r\n    });\r\n}\r\nfunction setValues(visualElement, definition) {\r\n    if (Array.isArray(definition)) {\r\n        return setVariants(visualElement, definition);\r\n    }\r\n    else if (typeof definition === \"string\") {\r\n        return setVariants(visualElement, [definition]);\r\n    }\r\n    else {\r\n        setTarget(visualElement, definition);\r\n    }\r\n}\r\nfunction checkTargetForNewValues(visualElement, target, origin) {\r\n    var _a, _b;\r\n    const newValueKeys = Object.keys(target).filter((key) => !visualElement.hasValue(key));\r\n    const numNewValues = newValueKeys.length;\r\n    if (!numNewValues)\r\n        return;\r\n    for (let i = 0; i < numNewValues; i++) {\r\n        const key = newValueKeys[i];\r\n        const targetValue = target[key];\r\n        let value = null;\r\n        /**\r\n         * If the target is a series of keyframes, we can use the first value\r\n         * in the array. If this first value is null, we'll still need to read from the DOM.\r\n         */\r\n        if (Array.isArray(targetValue)) {\r\n            value = targetValue[0];\r\n        }\r\n        /**\r\n         * If the target isn't keyframes, or the first keyframe was null, we need to\r\n         * first check if an origin value was explicitly defined in the transition as \"from\",\r\n         * if not read the value from the DOM. As an absolute fallback, take the defined target value.\r\n         */\r\n        if (value === null) {\r\n            value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement.readValue(key)) !== null && _b !== void 0 ? _b : target[key];\r\n        }\r\n        /**\r\n         * If value is still undefined or null, ignore it. Preferably this would throw,\r\n         * but this was causing issues in Framer.\r\n         */\r\n        if (value === undefined || value === null)\r\n            continue;\r\n        if (typeof value === \"string\" &&\r\n            (isNumericalString(value) || isZeroValueString(value))) {\r\n            // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\r\n            value = parseFloat(value);\r\n        }\r\n        else if (!findValueType(value) && complex.test(targetValue)) {\r\n            value = getAnimatableNone(key, targetValue);\r\n        }\r\n        visualElement.addValue(key, motionValue(value));\r\n        if (origin[key] === undefined) {\r\n            origin[key] = value;\r\n        }\r\n        visualElement.setBaseTarget(key, value);\r\n    }\r\n}\r\nfunction getOriginFromTransition(key, transition) {\r\n    if (!transition)\r\n        return;\r\n    const valueTransition = transition[key] || transition[\"default\"] || transition;\r\n    return valueTransition.from;\r\n}\r\nfunction getOrigin(target, transition, visualElement) {\r\n    var _a;\r\n    const origin = {};\r\n    for (const key in target) {\r\n        const transitionOrigin = getOriginFromTransition(key, transition);\r\n        origin[key] =\r\n            transitionOrigin !== undefined\r\n                ? transitionOrigin\r\n                : (_a = visualElement.getValue(key)) === null || _a === void 0 ? void 0 : _a.get();\r\n    }\r\n    return origin;\r\n}\r\n\r\nexport { checkTargetForNewValues, getOrigin, getOriginFromTransition, setTarget, setValues };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}